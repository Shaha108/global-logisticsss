<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Global Delivery Master | 3D TSP Challenge</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
  <script src="https://unpkg.com/globe.gl"></script>
  <style>
    /* ===== MODERN UI ===== */
    :root {
      --primary: #4361ee;
      --secondary: #3a0ca3;
      --accent: #f72585;
      --dark: #1a1a2e;
      --light: #f8f9fa;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--dark);
      color: var(--light);
      overflow: hidden;
      height: 100vh;
    }

    #globe-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .game-ui {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
    }

    .panel {
      background: rgba(26, 26, 46, 0.8);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      pointer-events: all;
    }

    .header {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 5px;
      background: linear-gradient(90deg, #f72585, #4361ee);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
    }

    button {
      background: var(--primary);
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: 50px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 5px 15px rgba(67, 97, 238, 0.3);
      font-size: 1rem;
    }

    button:hover {
      background: var(--secondary);
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(67, 97, 238, 0.4);
    }

    button:active {
      transform: translateY(0);
    }

    .stats {
      position: absolute;
      top: 20px;
      right: 20px;
      text-align: right;
    }

    .stats span {
      display: block;
      font-size: 1.2rem;
      margin-bottom: 5px;
    }

    #score {
      color: #4cc9f0;
      font-weight: bold;
    }

    #cities-count {
      color: #f72585;
    }

    /* ===== ANIMATIONS ===== */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .pulse {
      animation: pulse 2s infinite;
    }

    .path-animation {
      stroke-dasharray: 1000;
      stroke-dashoffset: 1000;
      animation: draw 3s linear forwards;
    }

    @keyframes draw {
      to {
        stroke-dashoffset: 0;
      }
    }
  </style>
</head>
<body>
  <!-- 3D Globe Container -->
  <div id="globe-container"></div>

  <!-- Game UI Overlay -->
  <div class="game-ui">
    <div class="header panel">
      <h1>GLOBAL DELIVERY MASTER</h1>
      <p>Optimize your worldwide delivery routes</p>
    </div>

    <div class="stats panel">
      <span id="score">Fuel: 0</span>
      <span id="cities-count">Cities: 0/8</span>
      <span id="time">Time: 60s</span>
    </div>

    <div class="controls">
      <button id="validate-btn">VALIDATE ROUTE</button>
      <button id="reset-btn">RESET</button>
      <button id="add-city-btn">ADD CITY</button>
      <button id="time-attack-btn">TIME ATTACK</button>
    </div>
  </div>

  <script>
    // =====================
    // GAME CONFIG
    // =====================
    const CONFIG = {
      INITIAL_CITIES: 8,
      MAX_CITIES: 15,
      FUEL_COST_PER_KM: 0.2,
      EARTH_RADIUS_KM: 6371,
      TIME_ATTACK_DURATION: 60
    };

    // Real-world major cities with coordinates
    const REAL_CITIES = [
      { name: "New York", lat: 40.7128, lng: -74.0060 },
      { name: "London", lat: 51.5074, lng: -0.1278 },
      { name: "Tokyo", lat: 35.6762, lng: 139.6503 },
      { name: "Paris", lat: 48.8566, lng: 2.3522 },
      { name: "Dubai", lat: 25.2048, lng: 55.2708 },
      { name: "Sydney", lat: -33.8688, lng: 151.2093 },
      { name: "Rio de Janeiro", lat: -22.9068, lng: -43.1729 },
      { name: "Cape Town", lat: -33.9249, lng: 18.4241 },
      { name: "Moscow", lat: 55.7558, lng: 37.6173 },
      { name: "Beijing", lat: 39.9042, lng: 116.4074 }
    ];

    // =====================
    // GAME STATE
    // =====================
    let cities = [];
    let selectedRoute = [];
    let totalFuel = 0;
    let globe;
    let pathObject;
    let timeLeft = CONFIG.TIME_ATTACK_DURATION;
    let timerInterval;
    let isTimeAttack = false;

    // =====================
    // INITIALIZE GLOBE
    // =====================
    function initGlobe() {
      const container = document.getElementById('globe-container');
      
      globe = Globe()
        .globeImageUrl('//unpkg.com/three-globe/example/img/earth-blue-marble.jpg')
        .bumpImageUrl('//unpkg.com/three-globe/example/img/earth-topology.png')
        .backgroundColor('rgba(0,0,0,0)')
        .showAtmosphere(true)
        .atmosphereColor('rgba(100, 150, 255, 0.2)')
        (container);

      // Add controls
      globe.controls().autoRotate = true;
      globe.controls().autoRotateSpeed = 0.5;
      globe.controls().enableZoom = true;
      globe.controls().enablePan = true;

      // Responsive sizing
      window.addEventListener('resize', () => {
        globe.width(window.innerWidth);
        globe.height(window.innerHeight);
      });
    }

    // =====================
    // GAME FUNCTIONS
    // =====================
    function initGame() {
      initGlobe();
      generateRandomCities(CONFIG.INITIAL_CITIES);
      setupEventListeners();
      updateUI();
    }

    function generateRandomCities(count) {
      cities = [];
      
      // Shuffle real cities and take the requested number
      const shuffled = [...REAL_CITIES].sort(() => 0.5 - Math.random());
      
      for (let i = 0; i < Math.min(count, shuffled.length); i++) {
        cities.push({
          id: i,
          name: shuffled[i].name,
          lat: shuffled[i].lat,
          lng: shuffled[i].lng,
          size: 0.3
        });
      }
      
      renderCities();
    }

    function renderCities() {
      // Clear existing cities
      globe.objectsData([]);
      
      // Add new cities with animation
      globe.objectsData(cities)
        .objectLat(d => d.lat)
        .objectLng(d => d.lng)
        .objectAltitude(d => 0.01)
        .objectRadius(d => d.size)
        .objectColor(d => selectedRoute.includes(d.id) ? '#f72585' : '#4361ee')
        .objectLabel(d => d.name)
        .objectAltitude(d => selectedRoute.includes(d.id) ? 0.02 : 0.01)
        .objectThreeObject(d => {
          const obj = new THREE.Mesh(
            new THREE.SphereGeometry(d.size, 16, 16),
            new THREE.MeshPhongMaterial({
              color: new THREE.Color(selectedRoute.includes(d.id) ? '#f72585' : '#4361ee'),
              emissive: '#111',
              shininess: 10
            })
          );
          obj.userData.id = d.id;
          return obj;
        });
    }

    function renderPath() {
      // Clear existing path
      if (pathObject) {
        globe.scene().remove(pathObject);
      }
      
      if (selectedRoute.length < 2) return;
      
      // Create path points
      const routePoints = selectedRoute.map(id => {
        const city = cities.find(c => c.id === id);
        return [city.lat, city.lng];
      });
      
      // Add closing loop if route is complete
      if (selectedRoute.length === cities.length) {
        const firstCity = cities.find(c => c.id === selectedRoute[0]);
        routePoints.push([firstCity.lat, firstCity.lng]);
      }
      
      // Create the path with animation
      const curve = new THREE.CatmullRomCurve3(
        routePoints.map(pt => {
          const coord = globe.getCoords(pt[0], pt[1], 0.01);
          return new THREE.Vector3(coord.x, coord.y, coord.z);
        }),
        false,
        'centripetal',
        0.5
      );
      
      const points = curve.getPoints(50);
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({
        color: 0xf72585,
        linewidth: 3,
        transparent: true,
        opacity: 0.8
      });
      
      pathObject = new THREE.Line(geometry, material);
      globe.scene().add(pathObject);
      
      // Animate path drawing
      geometry.setDrawRange(0, 0);
      let drawCount = 0;
      const total = geometry.attributes.position.count;
      const interval = setInterval(() => {
        drawCount += 2;
        geometry.setDrawRange(0, Math.min(drawCount, total));
        if (drawCount >= total) clearInterval(interval);
      }, 30);
    }

    function calculateDistance(lat1, lon1, lat2, lon2) {
      // Haversine formula
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return CONFIG.EARTH_RADIUS_KM * c;
    }

    function updateRoute() {
      // Calculate total distance
      totalFuel = 0;
      for (let i = 0; i < selectedRoute.length - 1; i++) {
        const city1 = cities.find(c => c.id === selectedRoute[i]);
        const city2 = cities.find(c => c.id === selectedRoute[i+1]);
        totalFuel += calculateDistance(city1.lat, city1.lng, city2.lat, city2.lng) * CONFIG.FUEL_COST_PER_KM;
      }
      
      // Render updates
      renderCities();
      renderPath();
      updateUI();
    }

    function updateUI() {
      document.getElementById('score').textContent = `Fuel: ${totalFuel.toFixed(0)}`;
      document.getElementById('cities-count').textContent = `Cities: ${selectedRoute.length}/${cities.length}`;
    }

    // =====================
    // GAME MODES
    // =====================
    function startTimeAttack() {
      isTimeAttack = true;
      timeLeft = CONFIG.TIME_ATTACK_DURATION;
      document.getElementById('time').style.display = 'block';
      updateTimerDisplay();
      
      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        timeLeft--;
        updateTimerDisplay();
        
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          validateRoute();
        }
      }, 1000);
    }

    function updateTimerDisplay() {
      const minutes = Math.floor(timeLeft / 60);
      const seconds = timeLeft % 60;
      document.getElementById('time').textContent = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
      
      if (timeLeft <= 10) {
        document.getElementById('time').style.color = '#ff6b6b';
      }
    }

    // =====================
    // EVENT HANDLERS
    // =====================
    function setupEventListeners() {
      // City selection
      document.getElementById('globe-container').addEventListener('click', (e) => {
        const intersects = globe.raycaster().intersectObjects(globe.scene().children, true);
        if (intersects.length > 0 && intersects[0].object.userData.id !== undefined) {
          const cityId = intersects[0].object.userData.id;
          selectCity(cityId);
        }
      });

      // Buttons
      document.getElementById('validate-btn').addEventListener('click', validateRoute);
      document.getElementById('reset-btn').addEventListener('click', resetGame);
      document.getElementById('add-city-btn').addEventListener('click', addCity);
      document.getElementById('time-attack-btn').addEventListener('click', startTimeAttack);
    }

    function selectCity(cityId) {
      if (!selectedRoute.includes(cityId)) {
        selectedRoute.push(cityId);
        updateRoute();
        
        // Fly to the selected city
        const city = cities.find(c => c.id === cityId);
        globe.pointOfView({ lat: city.lat, lng: city.lng, altitude: 2 }, 1000);
        
        // Pulse animation
        const cityObj = globe.scene().children.find(obj => 
          obj.userData && obj.userData.id === cityId
        );
        if (cityObj) {
          const scale = cityObj.scale.clone();
          cityObj.scale.set(scale.x * 1.5, scale.y * 1.5, scale.z * 1.5);
          setTimeout(() => {
            cityObj.scale.copy(scale);
          }, 300);
        }
      }
    }

    function validateRoute() {
      if (selectedRoute.length === 0) {
        alert("Please select at least one city!");
        return;
      }

      if (selectedRoute.length < cities.length) {
        alert(`You've only visited ${selectedRoute.length} out of ${cities.length} cities!`);
        return;
      }

      if (selectedRoute[0] !== selectedRoute[selectedRoute.length - 1]) {
        alert("Your route must end at the starting city!");
        return;
      }

      let message = `✅ Route Complete!\nFuel Used: ${totalFuel.toFixed(0)}`;
      
      if (isTimeAttack) {
        const timeBonus = Math.floor(timeLeft * 2);
        message += `\n⏱️ Time Bonus: +${timeBonus}`;
        totalFuel -= timeBonus;
        message += `\nFinal Score: ${totalFuel.toFixed(0)}`;
      }
      
      alert(message);
      resetGame();
    }

    function resetGame() {
      selectedRoute = [];
      totalFuel = 0;
      isTimeAttack = false;
      clearInterval(timerInterval);
      document.getElementById('time').style.display = 'none';
      document.getElementById('time').style.color = '#f8f9fa';
      updateRoute();
    }

    function addCity() {
      if (cities.length >= CONFIG.MAX_CITIES) {
        alert(`Maximum ${CONFIG.MAX_CITIES} cities reached!`);
        return;
      }
      
      // Get a city not already in our list
      const availableCities = REAL_CITIES.filter(rc => 
        !cities.some(c => c.name === rc.name)
      );
      
      if (availableCities.length === 0) return;
      
      const newCity = availableCities[Math.floor(Math.random() * availableCities.length)];
      
      cities.push({
        id: cities.length,
        name: newCity.name,
        lat: newCity.lat,
        lng: newCity.lng,
        size: 0.3
      });
      
      renderCities();
      updateUI();
    }

    // Start the game
    initGame();
  </script>
</body>
</html>
